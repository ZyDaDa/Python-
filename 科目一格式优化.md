

在使用 Python 刷算法题时，通常不需要额外安装许多库，因为 Python 的内置库已经提供了很多强大的工具。以下是一些常用的内置库和数据结构，可以帮助提高效率：

## 1. **`collections` 模块**
- **`Counter`**: 用于计数的哈希表，常用于频率统计。
- **`deque`**: 双端队列，支持 O(1) 的插入和删除操作。
- **`defaultdict`**: 带有默认值的字典，避免 KeyError。
- **`OrderedDict`**: 保持插入顺序的字典。
- **`namedtuple`**: 创建轻量级的不可变对象。

`collections` 模块是 Python 标准库中非常常用的一个模块，尤其在刷算法题时，它提供了一些高效的数据结构和工具函数，可以大大简化代码的编写，提高性能。下面是 `collections` 模块中的几个常用类及其刷题技巧。

### 1.1 **`Counter` 类**
`Counter` 是一个用于统计元素频率的容器，它底层基于字典，可以用于解决许多涉及到计数的问题，例如频率统计、词频分析、寻找重复元素等。

#### 常用方法：
- **`elements()`**：返回计数器中的元素。
- **`most_common([n])`**：返回出现频率最高的前 n 个元素。
- **`subtract()`**：两个计数器相减。

### 1.2 **`defaultdict` 类**
`defaultdict` 是一个字典的子类，它允许为字典中的键提供默认值，避免了访问不存在的键时报错（`KeyError`）。

#### 常用方法：
- **`defaultdict(<type>)`**：指定默认值类型，例如 `int`、`list` 等。

### 1.3 **`deque` 类**
`deque` 是双端队列，支持在队列的两端进行 O(1) 时间复杂度的插入和删除操作。适用于实现滑动窗口、广度优先搜索（BFS）等算法。

#### 常用方法：
- **`append()`**：在队尾插入元素。
- **`appendleft()`**：在队首插入元素。
- **`pop()`**：弹出队尾元素。
- **`popleft()`**：弹出队首元素。
- **`rotate()`**：队列旋转。

#### 常见应用：
1. **滑动窗口最大值问题**：
   ```python
   from collections import deque

   def maxSlidingWindow(nums, k):
       dq = deque()
       res = []

       for i in range(len(nums)):
           # 移除不在窗口内的元素
           if dq and dq[0] < i - k + 1:
               dq.popleft()

           # 移除小于当前元素的所有元素
           while dq and nums[dq[-1]] < nums[i]:
               dq.pop()

           dq.append(i)

           # 记录窗口的最大值
           if i >= k - 1:
               res.append(nums[dq[0]])

       return res

   print(maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3))
   # 输出：[3, 3, 5, 5, 6, 7]
   ```

2. **广度优先搜索（BFS）**：
   ```python
   from collections import deque

   def bfs(graph, start):
       visited = set()
       queue = deque([start])
       visited.add(start)

       while queue:
           node = queue.popleft()
           print(node)

           for neighbor in graph[node]:
               if neighbor not in visited:
                   visited.add(neighbor)
                   queue.append(neighbor)

   graph = {
       'A': ['B', 'C'],
       'B': ['A', 'D', 'E'],
       'C': ['A', 'F'],
       'D': ['B'],
       'E': ['B', 'F'],
       'F': ['C', 'E']
   }
   bfs(graph, 'A')
   ```

### 1.4 **`OrderedDict` 类**
`OrderedDict` 是保持插入顺序的字典。虽然在 Python 3.7 及之后版本，普通字典已经默认保持插入顺序，但在某些题目中，显式使用 `OrderedDict` 可以提高可读性。

#### 常见应用：
1. **按照顺序遍历**：
   ```python
   from collections import OrderedDict

   d = OrderedDict()
   d['apple'] = 3
   d['banana'] = 2
   d['orange'] = 1

   for key, value in d.items():
       print(key, value)
   # 输出：
   # apple 3
   # banana 2
   # orange 1
   ```

2. **LRU 缓存机制（最近最少使用）**：
   ```python
   from collections import OrderedDict

   class LRUCache:
       def __init__(self, capacity: int):
           self.cache = OrderedDict()
           self.capacity = capacity

       def get(self, key: int) -> int:
           if key not in self.cache:
               return -1
           self.cache.move_to_end(key)  # 更新最近使用
           return self.cache[key]

       def put(self, key: int, value: int) -> None:
           if key in self.cache:
               self.cache.move_to_end(key)
           self.cache[key] = value
           if len(self.cache) > self.capacity:
               self.cache.popitem(last=False)  # 删除最早使用的

   cache = LRUCache(2)
   cache.put(1, 1)
   cache.put(2, 2)
   print(cache.get(1))  # 输出: 1
   cache.put(3, 3)      # 淘汰 key 2
   print(cache.get(2))  # 输出: -1
   ```

### 1.5 **`namedtuple` 类**
`namedtuple` 创建一个轻量级的不可变对象，可以像访问属性一样访问元组中的元素，常用于保持数据的结构性和可读性。

#### 常见应用：
1. **在树或链表节点中使用 `namedtuple`**：
   ```python
   from collections import namedtuple

   Node = namedtuple('Node', ['value', 'left', 'right'])

   tree = Node(1, Node(2, None, None), Node(3, None, None))
   print(tree.left.value)  # 输出：2
   ```



---

## 2. **`heapq` 模块**
`heapq` 模块是 Python 标准库中用于堆（heap）算法的模块，主要提供了最小堆的实现，适用于优先队列等数据结构。

### 2.1 **基本概念**
- **最小堆**：一种特殊的完全二叉树，每个节点的值小于或等于其子节点的值。`heapq` 默认实现的是最小堆。
- **优先队列**：可以根据优先级高低处理元素，使用最小堆实现，确保高效的插入和删除操作。

### 2.2 **常用函数**
1. **`heapify(iterable)`**  
   将可迭代对象（如列表）转换为堆，原地排序。  
   ```python
   import heapq

   nums = [3, 1, 4, 1, 5, 9, 2]
   heapq.heapify(nums)
   print(nums)  # 输出： [1, 1, 2, 3, 5, 9, 4]（最小堆）
   ```

2. **`heappush(heap, item)`**  
   将元素 `item` 推入堆 `heap` 中。  
   ```python
   heap = []
   heapq.heappush(heap, 3)
   heapq.heappush(heap, 1)
   heapq.heappush(heap, 4)
   print(heap)  # 输出：[1, 3, 4]
   ```

3. **`heappop(heap)`**  
   从堆中弹出并返回最小元素。

4. **`heappushpop(heap, item)`**  
   将 `item` 推入堆中，然后弹出并返回最小元素，操作效率更高。

5. **`heapreplace(heap, item)`**  
   弹出并返回最小元素，然后将 `item` 推入堆中，此操作效率更高。

6. **`nlargest(n, iterable, key=None)`**  
   返回可迭代对象 `iterable` 中的前 `n` 大元素，支持 `key` 函数排序。  
   ```python
   largest = heapq.nlargest(3, [1, 3, 5, 2, 4])
   print(largest)  # 输出：[5, 4, 3]
   ```

7. **`nsmallest(n, iterable, key=None)`**  
   返回可迭代对象 `iterable` 中的前 `n` 小元素。

### 2.3 **常见应用**
1. **合并 K 个排序列表**  
   使用最小堆合并多个已排序的列表。  
   ```python
   def merge_k_sorted_lists(lists):
       min_heap = []
       for i, lst in enumerate(lists):
           if lst:  # 如果列表不为空
               heapq.heappush(min_heap, (lst[0], i, 0))  # (值, 列表索引, 元素索引)

       result = []
       while min_heap:
           value, list_index, element_index = heapq.heappop(min_heap)
           result.append(value)
           if element_index + 1 < len(lists[list_index]):
               next_tuple = (lists[list_index][element_index + 1], list_index, element_index + 1)
               heapq.heappush(min_heap, next_tuple)

       return result

   lists = [[1, 4, 5], [1, 3, 4], [2, 6]]
   print(merge_k_sorted_lists(lists))  # 输出：[1, 1, 2, 3, 4, 4, 5, 6]
   ```

2. **查找前 K 个最大元素**  
   使用 `nlargest` 函数快速查找。  
   ```python
   def top_k_elements(nums, k):
       return heapq.nlargest(k, nums)

   print(top_k_elements([3, 1, 4, 1, 5, 9], 3))  # 输出：[9, 5, 4]
   ```

3. **求中位数**  
   维护两个堆以实现高效的中位数查找。  
   ```python
   import heapq

   class MedianFinder:
       def __init__(self):
           self.max_heap = []  # 小顶堆
           self.min_heap = []  # 大顶堆

       def addNum(self, num: int) -> None:
           heapq.heappush(self.max_heap, -num)  # 将 num 转为负数存入 max_heap
           if (self.max_heap and self.min_heap and
                   (-self.max_heap[0] > self.min_heap[0])):
               val = -heapq.heappop(self.max_heap)
               heapq.heappush(self.min_heap, val)

           if len(self.max_heap) > len(self.min_heap) + 1:
               val = -heapq.heappop(self.max_heap)
               heapq.heappush(self.min_heap, val)
           elif len(self.min_heap) > len(self.max_heap):
               val = heapq.heappop(self.min_heap)
               heapq.heappush(self.max_heap, -val)

       def findMedian(self) -> float:
           if len(self.max_heap) > len(self.min_heap):
               return -self.max_heap[0]
           return (-self.max_heap[0] + self.min_heap[0]) / 2.0
   ```

---



## 3. **`itertools` 模块**
包含一组高效的迭代工具，常用于生成排列、组合、笛卡尔积等。

```python
import itertools

# 生成排列
perm = list(itertools.permutations([1, 2, 3]))
print(perm)  # 输出：[(1, 2, 3), (1, 3, 2), (2, 1, 3), ...]

# 生成组合
comb = list(itertools.combinations([1, 2, 3], 2))
print(comb)  # 输出：[(1, 2), (1, 3), (2, 3)]
```

---

## 4. **`functools` 模块**
`functools` 模块提供了一组高阶函数和操作工具，主要用于简化和优化函数操作。以下是该模块的一些常用功能及其在算法中的应用。

### 4.1 **常用函数和类**

1. **`lru_cache(maxsize=None)`**  
   缓存函数的返回值，以提高递归或重复计算的效率，采用最近最少使用（LRU）策略管理缓存。
   - **参数**：`maxsize`：缓存最大大小，默认 `None`（无限制）。

   **应用示例**：优化 Fibonacci 数列计算。
   ```python
   from functools import lru_cache

   @lru_cache(maxsize=None)
   def fib(n):
       if n < 2:
           return n
       return fib(n - 1) + fib(n - 2)

   print(fib(100))  # 输出：354224848179261915075
   ```

2. **`reduce(function, iterable[, initializer])`**  
   对可迭代对象中的元素进行累积操作，通常用于计算聚合结果。
   - **参数**：
     - `function`：接受两个参数的函数，用于聚合。
     - `iterable`：要处理的可迭代对象。
     - `initializer`：可选，作为初始值。

   **应用示例**：计算列表中的元素乘积。
   ```python
   from functools import reduce

   nums = [1, 2, 3, 4]
   product = reduce(lambda x, y: x * y, nums)
   print(product)  # 输出：24
   ```

3. **`partial(func, /, *args, **kwargs)`**  
   创建一个新函数，固定某些参数，简化函数调用。
   - **参数**：
     - `func`：原始函数。
     - `*args`：位置参数。
     - `**kwargs`：关键字参数。

   **应用示例**：简化数学运算。
   ```python
   from functools import partial

   def power(base, exp):
       return base ** exp

   square = partial(power, exp=2)
   print(square(3))  # 输出：9
   ```

4. **`cmp_to_key(func)`**  
   将旧式比较函数转换为关键字参数函数，以便在 `sort()` 和 `sorted()` 中使用。

   **应用示例**：自定义排序规则。
   ```python
   from functools import cmp_to_key

   def compare(x, y):
       return (x > y) - (x < y)  # 返回 -1, 0, 1

   data = [3, 1, 2]
   sorted_data = sorted(data, key=cmp_to_key(compare))
   print(sorted_data)  # 输出：[1, 2, 3]
   ```

5. **`update_wrapper(wrapper, wrapped, ...)`**  
   更新装饰器的元信息，使其与被装饰的函数保持一致，适用于自定义装饰器。

   **应用示例**：保留原始函数的信息。
   ```python
   from functools import wraps

   def my_decorator(func):
       @wraps(func)
       def wrapper(*args, **kwargs):
           print("Before calling:", func.__name__)
           return func(*args, **kwargs)
       return wrapper

   @my_decorator
   def say_hello():
       print("Hello!")

   say_hello()
   print(say_hello.__name__)  # 输出：say_hello
   ```

### 4.2 **常见应用**

1. **动态规划**  
   使用 `lru_cache` 优化递归算法，适用于 Fibonacci 数列、背包问题等。
   ```python
   @lru_cache(maxsize=None)
   def knapsack(weights, values, capacity):
       if capacity <= 0 or not weights:
           return 0
       if weights[0] > capacity:
           return knapsack(weights[1:], values[1:], capacity)
       include = values[0] + knapsack(weights[1:], values[1:], capacity - weights[0])
       exclude = knapsack(weights[1:], values[1:], capacity)
       return max(include, exclude)
   ```

2. **组合函数**  
   使用 `partial` 简化多个函数调用。
   ```python
   from math import pow

   square = partial(pow, exp=2)
   print(square(5))  # 输出：25.0
   ```

3. **自定义排序**  
   使用 `cmp_to_key` 实现复杂排序规则。
   ```python
   def custom_sort(x, y):
       return len(x) - len(y)

   words = ["apple", "pear", "fig", "banana"]
   sorted_words = sorted(words, key=cmp_to_key(custom_sort))
   print(sorted_words)  # 输出：['fig', 'pear', 'apple', 'banana']
   ```
---

## 5. **`bisect` 模块**
`bisect` 模块用于维护已排序列表的顺序，提供高效的查找插入位置和二分查找功能。以下是常用功能的介绍及其应用示例。

### 5.1 **常用函数**

1. **`bisect.bisect_left(a, x, lo=0, hi=len(a))`**  
   返回 `x` 应该插入的位置，使得 `a` 仍保持有序（左边界插入）。
   - **参数**：
     - `a`：已排序列表。
     - `x`：要插入的元素。
     - `lo`：查找的起始索引（默认 0）。
     - `hi`：查找的结束索引（默认 `len(a)`）。

   **示例**：
   ```python
   import bisect

   sorted_list = [1, 3, 4, 4, 5, 6]
   position = bisect.bisect_left(sorted_list, 4)
   print(position)  # 输出：2
   ```

2. **`bisect.bisect_right(a, x, lo=0, hi=len(a))`**  
   返回 `x` 应该插入的位置（右边界插入）。

3. **`bisect.insort_left(a, x, lo=0, hi=len(a))`**  
   在已排序列表 `a` 中插入元素 `x`（左边界插入）。

   **示例**：
   ```python
   bisect.insort_left(sorted_list, 4)
   print(sorted_list)  # 输出：[1, 3, 4, 4, 4, 5, 6]
   ```

4. **`bisect.insort_right(a, x, lo=0, hi=len(a))`**  
   在已排序列表 `a` 中插入元素 `x`（右边界插入）。

### 5.2 **常见应用**

用于动态维护有序列表并快速查找插入位置。

```python
def maintain_sorted_list(sorted_list, new_value):
    bisect.insort(sorted_list, new_value)
    return sorted_list

sorted_list = [1, 3, 4, 5]
print(maintain_sorted_list(sorted_list, 2))  # 输出：[1, 2, 3, 4, 5]
```

---

## 6. **`math` 模块**
`math` 模块提供多种常用数学函数和常量，以下是常用函数及应用示例。

### 6.1 **常用函数**

1. **`math.sqrt(x)`**  
   返回 `x` 的平方根。

2. **`math.pow(x, y)`**  
   返回 `x` 的 `y` 次幂。

3. **`math.factorial(x)`**  
   返回 `x` 的阶乘（`x` 为非负整数）。

4. **`math.gcd(a, b)`**  
   返回 `a` 和 `b` 的最大公约数。

5. **`math.sin(x)`、`math.cos(x)`、`math.tan(x)`**  
   返回 `x`（弧度）的正弦、余弦和正切值。

6. **`math.asin(x)`、`math.acos(x)`、`math.atan(x)`**  
   返回 `x` 的反三角函数值（结果为弧度）。

7. **`math.log(x, base)`**  
   返回 `x` 的以 `base` 为底的对数（未指定 `base` 返回自然对数）。

8. **`math.exp(x)`**  
   返回 `e` 的 `x` 次幂。

9. **`math.ceil(x)` 和 `math.floor(x)`**  
   `ceil` 返回大于或等于 `x` 的最小整数，`floor` 返回小于或等于 `x` 的最大整数。

10. **`math.pi` 和 `math.e`**  
    常量，分别表示圆周率 π 和自然对数的底数 e。

### 6.2 **常见应用**

使用平方根和公式求解一元二次方程的根。

```python
def quadratic_formula(a, b, c):
    d = math.sqrt(b**2 - 4*a*c)  # 判别式
    return (-b + d) / (2*a), (-b - d) / (2*a)

print(quadratic_formula(1, -3, 2))  # 输出：(2.0, 1.0)
```

---

## 7. **`operator` 模块**
`operator` 模块提供了一组函数，用于执行常见操作符，提升代码可读性和性能。

### 7.1 **常用函数**

1. **算术运算符**  
   - **`operator.add(a, b)`**：返回 `a + b`。
   - **`operator.sub(a, b)`**：返回 `a - b`。
   - **`operator.mul(a, b)`**：返回 `a * b`。
   - **`operator.truediv(a, b)`**：返回 `a / b`。

2. **比较运算符**  
   - **`operator.eq(a, b)`**：返回 `a == b` 的布尔值。
   - **`operator.ne(a, b)`**：返回 `a != b` 的布尔值。
   - **`operator.lt(a, b)`**：返回 `a < b` 的布尔值。
   - **`operator.gt(a, b)`**：返回 `a > b` 的布尔值。

3. **逻辑运算符**  
   - **`operator.and_(a, b)`**：返回 `a and b`。
   - **`operator.or_(a, b)`**：返回 `a or b`。
   - **`operator.not_(a)`**：返回 `not a`。

4. **序列操作**  
   - **`operator.getitem(obj, key)`**：返回 `obj[key]`。
   - **`operator.setitem(obj, key, value)`**：设置 `obj[key] = value`。
   - **`operator.delitem(obj, key)`**：删除 `obj[key]`。

5. **函数操作**  
   - **`operator.callable(obj)`**：判断 `obj` 是否可调用。
   - **`operator.methodcaller(name, *args)`**：返回可调用对象，调用时调用 `name` 方法。

**示例**：
```python
class MyClass:
    def greet(self):
        return "Hello!"

greet_func = operator.methodcaller('greet')
my_instance = MyClass()
print(greet_func(my_instance))  # 输出：Hello!
```

### 7.2 **常见应用**

1. **排序**  
   使用 `operator` 函数作为 `sorted()` 的关键字参数。

   ```python
   data = [('apple', 2), ('banana', 3), ('cherry', 1)]
   sorted_data = sorted(data, key=operator.itemgetter(1))
   print(sorted_data)  # 输出：[('cherry', 1), ('apple', 2), ('banana', 3)]
   ```

2. **映射与过滤**  
   结合 `map()` 和 `filter()` 使用 `operator` 函数。

   ```python
   numbers = [1, 2, 3, 4, 5]
   squared = list(map(operator.pow, numbers, [2]*len(numbers)))  # 每个数平方
   print(squared)  # 输出：[1, 4, 9, 16, 25]

   filtered = list(filter(operator.gt, numbers, [3]*len(numbers)))  # 过滤大于 3 的数
   print(filtered)  # 输出：[4, 5]
   ```
